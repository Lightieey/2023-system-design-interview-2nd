# 1장 사용자 수에 따른 규모 확장성
작은 시스템부터 시작해 매우 크고 복잡한 시스템 설계까지 단계적으로 알아보자.
<br><br>

## 단일 서버
![Screenshot 2023-08-20 at 1 48 15 AM](https://github.com/Lightieey/2023-system-design-interview-2nd/assets/79203421/0b7e4dc3-1554-4434-9c22-b379418f2cd4)

가장 간단한 구성으로, 웹 앱, 데이터베이스, 캐시 등의 모든 컴포넌트가 단 한대의 서버에서 실행되는 시스템이다.<br>
1-2학년 때 데이터베이스를 배우기 전에는 이런 구성으로 플젝을 만들었던 것 같다
<br><br>

## 데이터베이스
![Screenshot 2023-08-20 at 1 51 19 AM](https://github.com/Lightieey/2023-system-design-interview-2nd/assets/79203421/8eaba7bb-5c6a-4934-ac45-9f06d4418e3d)

다음으로는 데이터베이스용 서버를 분리하는 구조이다. <br>
이게 보통 대학생들이 동아리에서 하는 플젝 수준이지 않을까 싶다 🤔

### 어떤 데이터베이스를 사용할 것인가?
사실 지금까지는 별 생각 없이 RDB를 써왔는데, 내가 어떤 이유로 이 DB를 선택했는지도 생각해보면 좋을 것 같다.
- RDBMS
  - MySQL, Oracle, PostgreSQL 등
  - 여러 테이블에 있는 데이터를 그 관계에 따라 조인하여 합칠 수 있다.
- NoSQL
  - MongoDB, CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB 등
  - 조인 연산을 지원하지 않는다.
  - 아주 낮은 응답 지연시간이 요구되는 경우나 아주 많은 양의 데이터를 저장해야 할 때 사용한다.
<br><br>

## 수직적 규모 확장 vs 수평적 규모 확장
수직적 규모 확장(=scale up, vertical scaling)은 다음의 단점을 가진다.
- 수직적 규모 확장에는 한계가 있다.
- 수직적 규모 확장법은 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시하지 않는다.

따라서, 대규모 시스템에서는 수평적 규모 확장(=scale out, horizontal scaling)이 더 적절하다.
<br><br>

## 로드밸런서
![Screenshot 2023-08-20 at 2 19 39 AM](https://github.com/Lightieey/2023-system-design-interview-2nd/assets/79203421/f6d1a6f6-0b82-45f4-bc89-f274f17559e0)

앞서 본 설계에서는 서버가 하나였기 때문에, 서버가 다운되면 사용자는 웹사이트에 접속할 수 없다. <br>
또한, 트래픽이 증가해 서버가 한계 상황에 도달하면 응답 속도가 느려지거나 서버 접속이 불가능해질 수도 있다. <br>
이런 문제를 해결하기 위해 수평적 규모 확장(=scale out)과 더불어 로드밸런서를 도입한다.
* 여기서, 클라이언트는 DNS서버에서 로드밸런서의 IP주소를 받아 접속하게 된다.
* 로드밸런서와 서버 간 통신에는 Private IP주소를 사용한다.
<br><br>

## 데이터베이스 다중화
![Screenshot 2023-08-20 at 2 38 55 AM](https://github.com/Lightieey/2023-system-design-interview-2nd/assets/79203421/c4b63046-e1d5-44ca-9e20-14fd778cb659)

앞선 설계에서 로드밸런서와 scale out을 통해 서버를 다중화했기 때문에, <br>
서버 하나가 문제가 생기더라도 failover가 가능해 웹 계층의 가용성이 향상되었다.<br>
그럼 이제 데이터베이스를 다중화해 데이터 계층의 가용성을 향상시킬 차례이다.<br>
데이터베이스 같은 경우, Source-Replica(=Master-Slave) 구조를 통해 다중화를 한다.
- Source DB에는 쓰기 연산(create, update, delete)을 한다.
- Replica DB에는 읽기 연산만 한다.

대부분의 애플리케이션은 읽기 연산의 비중이 훨씬 크기 때문에 이러한 구조를 통해 성능을 높일 수 있다.<br>
또한, Source DB에 장애가 생겼을 경우 Replica DB 중 하나를 Source DB로 대체하기 때문에 가용성과 안정성이 높아진다. 
<br><br>

## 캐시
이제는 시스템의 응답 시간을 개선해볼 순서이다. 이를 위해 첫 번째로 캐시에 대해 알아보자.<br>
애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우되기 때문에, 캐시를 통해 이런 문제를 완화할 수 있다.
- 캐시는 데이터 갱신을 자주 일어나지 않지만 참조(=조회)는 빈번하게 일어날 때 사용하는 것이 좋다.
- 캐시는 휘발성 메모리이므로, 영구적으로 보관이 필요하지 않은 데이터만 저장해야 한다.
- 캐시에 보관될 데이터의 만료 정책을 적절하게 설정해야 한다.
- 저장소 원본과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되어야 일관성 유지가 가능하다.
- 캐시 서버를 한 대만 두는 경우 단일 장애 지점(Single Point of Failure, SPOF)이 될 수 있으므로 캐시 서버를 분산시켜야 한다.
- 캐시 메모리 크기를 eviction이 자주 일어나지 않도록 설정해야 한다.
- 애플리케이션에 맞는 적절한 데이터 방출 정책을 세워야 한다.
<br><br>

## CDN
시스템의 응답 시간을 개선하는 또 다른 방법으로, CDN이 있다. <br>
정적 콘텐츠를 캐싱해 사용자에게 가까운 CDN 서버에서 데이터를 받을 수 있도록 한다. 
- 캐싱할 콘텐츠의 만료 시간을 적절하게 설정해야 한다.
- CDN 장애에 대한 대처 방안을 세워야 한다.
- 캐싱한 콘텐츠의 무효화 방법을 고려해야 한다.

아래 그림은 캐시와 CDN을 추가한 설계이다.<br>
![Screenshot 2023-08-20 at 2 54 39 AM](https://github.com/Lightieey/2023-system-design-interview-2nd/assets/79203421/c33af34b-638c-4fb2-a811-0373863f9887)
<br><br>

## 무상태 웹 계층 (무상태 아키텍처)
웹 계층의 서버가 확장될 때, 여러 서버들 간에 상태 정보 의존성을 없애기 위해 사용자 세션 데이터와 같은 정보를 웹 계층과 분리해야 한다.<br>
상태 정보에 의존적인 아키텍처인 경우, 클라이언트가 특정 서버와 통신을 주고받다가 다른 서버로 연결이 바뀌었을 때<br>
새로운 서버에는 해당 클라이언트와 통신했던 상태 정보가 없기 때문에 처음부터(ex.로그인부터) 통신을 다시 해야하는 것이다.

무상태 아키텍처에서는 상태 정보가 웹 서버 계층으로부터 분리되어 있기 때문에, 모든 서버가 동일한 상태 정보를 공유할 수 있다. <br>
따라서, 클라이언트 입장에서는 어떤 서버와 연결이 되든 상관없이 통신을 할 수 있는 것이다.

![Screenshot 2023-08-20 at 3 14 43 AM](https://github.com/Lightieey/2023-system-design-interview-2nd/assets/79203421/2f4bce17-e2c3-4832-bf79-4682802a6f01)
<br><br>

## 데이터 센터
우리의 애플리케이션에 사용자가 더 많아져 전세계를 대상으로 쾌적하게 서비스해야 한다고 해보자.<br>
이런 경우에는 여러 개의 데이터 센터를 이용한다.<br>
아래 그림에서 초록색 박스가 하나의 데이터 센터가 되고, 로드밸런서는 지리적 라우팅을 통해 사용자에게 가장 가까운 데이터 센터로 안내를 한다.

![Screenshot 2023-08-20 at 3 24 14 AM](https://github.com/Lightieey/2023-system-design-interview-2nd/assets/79203421/96752b51-2814-479e-ac55-ac7471f5670e)
<br><br>

## 메시지 큐
메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적인 애플리케이션을 구성하기 좋다.<br>
다시 말해, 트래픽(=큐의 크기)에 따라 생산자 서비스와 소비자 서비스를 따로 확장할 수 있다는 것이다.

![Screenshot 2023-08-20 at 3 35 00 AM](https://github.com/Lightieey/2023-system-design-interview-2nd/assets/79203421/a7fc2806-84a7-4e17-824f-7b0a873bede2)
<br><br>

## 로그, 메트릭, 그리고 자동화
사업 규모가 커지면 로그와 메트릭, 자동화 시스템을 구축해 개발 생산성을 크게 향상시킬 수 있다.
<br><br>

## 데이터베이스의 규모 확장
데이터베이스 역시 수직적 확장과 수평적 확장을 할 수 있는데, 그 중 수평적 확장 방법인 샤딩(Sharding)을 알아보자.<br>
샤딩은 대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술이다.<br>
모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.<br>
샤딩 전략을 구현할 때 고려해야할 가장 중요한 것은 샤딩 키(=파티션 키)를 어떻게 정하느냐 하는 것이다.<br>
샤딩 키는 데이터를 고르게 분할할 수 있도록 하는 게 가장 중요하다.<br>

