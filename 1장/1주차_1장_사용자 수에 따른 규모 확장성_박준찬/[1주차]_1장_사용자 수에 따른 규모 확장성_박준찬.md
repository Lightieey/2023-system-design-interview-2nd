# 1장 사용자 수에 따른 규모 확장성
##### 시스템 규모 확장을 위한 기법 정리
- 웹 계층은 무상태 계층으로
- 모든 계층에 다중화 도입
- 가능한 한 많은 데이터를 캐시할 것
- 여러 데이터 센터를 지원할 것
- 정적 콘텐츠는 CDN을 통해 서비스할 것
- 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
- 각 계층은 독립적 서비스로 분할할 것
- 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것
----
### 1. 무상태 웹 계층
-- 상태 정보를 보관하는 공유 저장소(share sotrage)를 둠으로써 웹서버로부터 물리적으로 분리한다. 이를 통해, 웹서버에 종속되는 정보(상태)를 없앤다. 클라이언트로부터의 요청이 한 서버에 종속되면 로드밸런서의 고정세션이라는 기능을 사용해야 하는데, 이는 로드밸런서에게 부담을 준다.
### 2. 다중화
-- 서버는 **스케일 업**(수직적 규모 확장)과 **스케일 아웃**(수평적 규모 확장)을 통해 서버 성능을 개선할 수 있다. 스케일 업은 서버 사양을 높이는 방법으로 한계가 존재하고, 장애에 대한 자동복구 방안이나 다중화 방안을 제시하지 않는다. 하지만 스케일 아웃은 자동복구 문제를 해소할 뿐 아니라, 웹 계층의 가용성을 향상해준다.
- 웹서버 다중화
-- 웹서버의 스케일 아웃을 위해서 **로드밸런서**를 사용하면 된다. 사용자는 로드밸런서의 public IP address로 접근하게 되고, 로드밸런서는 private IP address를 이용하여 웹 서버와 통신한다. 외부에서 직접 접근하지 못한다는 면에서 보안 또한 향상되는 효과를 가져온다.
- 데이터베이스 다중화
-- 데이터베이스의 다중화는 주와 부를 나누어(master-slave), master 서버에서는  데이터의 원본을 저장하고, 나머지 서버가 사본을 저장하는 방식이다. 이 처럼 다중화를 하면 모든 데이터 변경 연산은 master 서버로, 데이터 조회 연산은 slave로 분산된다. 병렬로 처리할 수 있는 질의의 수가 늘어나므로, 성능이 좋아진다. 또한, 주 서버에 장애가 발생되어도 부 서버 중 하나를 주 서버로 승격시킴으로써 가용성을 높일 수 있다.
### 3. 캐시
-- 별도의 캐시 계층을 두면 성능이 개선될 뿐 아니라, 데이터베이스의 부하를 줄일 수 있고, 캐시 계층의 규모를 독립적으로 확장시킬 수 있다.
-- 캐시 사용 시 유의할 점
- 데이터 갱신이 자주 일어나지 않지만, 참조가 빈번히 일어나는 상황에 고려해야 한다.
- 영속적으로 보관할 데이터를 캐싱하는 것은 바람직하지 않다. 캐시는 휘발성이기 때문에 중요한 데이터는 지속적 저장소에 두어야 한다.
- 데이터의 만료 기한은 정해두는 것이 좋다. 너무 짧지도, 길지도 않게 설정해야 한다.
- 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜재겻ㄴ으로 처리되지 않는 경우 일관성이 깨질 수 있음을 주의한다.
- 캐시 서버도 단일화를 고려해야 한다. 단일 캐시 서버는 SPOF(단일 장애 지점)이 되어버릴 가능성이 있다.
- 캐시 메모리가 너무 작으면 캐시에 저장되는 데이터가 적어 효율이 떨어진다. 메모리를 과할당 하면 된다.
- 데이터 방출 정책은 주로 **LRU**(Least-Recently-used)를 사용하고, 다른 정책으로는 LFU, FIFO가 있다.


### 4. 데이터 센터
-- 데이터 센터를 다중으로 관리하면 한 데이터 센터에서 장애를 일으킬 경우, 다른 데이터 센터로 트래픽을 전송함으로써 장애를 방지할 수 있다.
-- 하지만 다중 데이터센터 아키텍처를 만드려면 몇 가지 기술적 난제를 해결해야 한다.
- 트래픽 우회
-- 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야 한다. **GeoDNS**는 사용자에게서 가장 가까운 데이터센터로 트래피을 보낼 수 있도록 해준다.

- 데이터 동기화
-- 데이터센터마다 별도의 데이터베이스를 두고 있는 상황이라면 장애 발생 시, 다른 데이터센터의 데이터베이스에 찾는 데이터가 없을 수 있다. 이런 상황을 막는 보편적 전략은 데이터를 여러 데이터센터에 걸쳐 다중화하는 것이다.
- 테스트 및 배포
-- 여러 위치에서 테스트를 해보아야 한다. 자동화된 배포 도구로 모든 데이터 센터에 동일한 서비스가 설치되도록 해야 한다.
### 5. CDN
-- CDN은 정적 컨텐츠를 전송하는 데에 쓰이는 지리적으로 분산된 서버의 네트워크이다. 이미지, 비디오, CSS, JavaScript 파일 등을 캐시할 수 있다. 동적 콘텐츠 캐싱도 상대적으로 새로운 기술로, 동적 콘텐츠 역시 캐싱이 가능하다.
-- CDN 사용 시 고려해야할 사항
- 비용: 자주 사용되지 않는 콘텐츠는 캐싱하지 않도록 하자.
- 적절한 만료 시한 설정: 시의성이 중요한 콘텐츠의 경우 만료 시점을 잘 정해야 한다.
- CDN 장애 발생 시 원본 서버 지점으로 요청을 보내는 등, CDN 장애 발생 시 방안을 마련해야 한다.

### 6. 샤딩
-- 데이터베이스의 수평적 확장 중 하나이다. 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술을 일컫는다. 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다. 샤딩 키는 파티션 키라고도 불린다. 샤딩 키를 정할 때, 데이터를 고르게 분할할 수 있도록 하는 게 가장 중요한다.
-- 샤딩을 도입하면 풀어야할 새로운 문제가 발생한다.
- 데이터 재샤딩(resharding)
-- 재샤딩은 다음과 같은 경우에 필요하다. (1) 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때, (2) 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때
-- 이는 샤드 소진(shard exchaustion)이라고도 불린다. 이런 현상이 발생하면 샤드 키를 계싼하는 함수를 변경하고 데이터를 재배치하여야 한다.

- celebrity(유명인사) 문제
-- 핫스팟 키(hotspot key) 문제라고도 부른느데, 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제이다. 가령 케이티 페리, 저스틴 비버와 같은 유명인사가 존재할 때, 이러한 유명인사가 포함된 샤드는 질의가 집중된다. 이러한 문제를 풀기 위해 유명인사를 샤드에 하나씩 할당하거나, 심지어 더 잘게 쪼개야 할 수도 있다.
- 조인과 비정규화
-- 하나의 데이터베이스를 여러 샤드 서버로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다. 이를 해결하는 한가지 방법은 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것이다.

### 7. 독립적 서비스로 분할(message queue)
-- 시스템이 매우 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여, 각기 독립적으로 확장될 수 있어야 한다. **메시지 큐(message queue)**는 많은 실제 분산 시스템이 이 문제를 풀기 위해 채용하고 있는 핵심적 전략 중 하나다.
-- 메시지 큐는 메시지의 무손실을 보장하는 비동기 통신을 지원하는 컴포넌트다. 생산자와 소비자를 비동기로 분리하여 서비스간, 서버간의 결합도를 낮춘다. 이를 통해 각 서버를 독립적으로 확장할 수 있다. 
### 8. 모니터링, 자동화 도구
-- 로그
- 에러 로그를 모니터링하는 것은 중요하다. 서버 단위로 모니터링할 수도 있지만, 서비스 단위로 로그를 모아주는 도구를 활용한다면 편리하게 검색, 조회할 수 있다.

-- 메트릭
- 호스트 단위 메트릭: CPU, 메모리, 디스크 I/O에 관한 메트릭이 여기에 해당한다.
- 종합 메트릭: 데이터베이스 계층의 성능, 캐시 계층의 성능같은 것이 여기에 해당한다.
- 핵심 비즈니스 메트릭: 일별 능동 사용자, 수익, 재방문 같은 것이 여기 해당한다.

-- 자동화
- CICD를 도입함으로써 생산성을 높일 수 있다
-----

## 캐싱 전략의 종류
##### 캐시 읽기 전략
- look aside(Lazy Loading) 전략
-- 데이터를 찾을 때 우선 캐시에 저장된 데이터가 있는지 우선적으로 확인하는 전략
-- 데이터를 읽는 작업이 많을 때 사용하는 전략이며, 레디스를 캐시로 쓸 때 가장 많이 사용
- read thorugh(inline cache) 전략
-- 캐시에서만 데이터를 읽어오는 전략
-- 데이터 동기화를 캐시 제공자에게 위임하는 방식
-- 캐시와 DB간의 데이터 동기화가 항상 이루어져 데이터 정합성 문제에서 벗어날 수 있으나, 전체적으로 속도가 느리고, 캐시 서버가 다운될 경우 서비스 이용에 문제가 생김
##### 캐시 쓰기 전략
- write around 패턴
-- 모든 데이터는 DB에 저장(캐시를 갱신하지 않음) Cache miss가 발생한 경우에만 DB와 캐시에도 데이터를 저장
-- 따라서 캐시와 DB 내의 데이터가 다를 수 있으나, write through 방식보다 훨씬 빠름

- write back 패턴
-- 데이터를 저장할 때 DB에 바로 쿼리하지 않고 캐시에 모아서 일정 주기 배치 작업을 통해 DB에 반영
-- 한 번에 저장하므로 쓰기 쿼리 비용과 부하를 줄일 수 있으나, 자주 사용되지 않는 불필요한 리소스를 저장할 수도 있음

- write throw 패턴
-- 데이터를 저장할 때 먼저 캐시에 저장한 다음 바로 DB에 저장( 모아놓았다가 나중 저장이 아닌 바로 저장)
-- DB와 캐시가 항상 동기화 되어 있어 데이터 정합성을 유지할 수 있지만, 자주 사용되지 않는 불필요한 리소스 낭비가 발생. 매 요청마다 두번의 Write가 발생함으로 써 빈번한 생성, 수정이 발생하는 서비스에는 부적합

##### 캐시 읽기 + 쓰기 전략 조합
- look aside + write around 조합
-- 가장 일반적으로 쓰이는 조합
- read through + write around 조합
-- 항상 DB에 쓰고, 캐시에서 읽ㅇ르 때 항상 DB에서 먼저 읽어오므로 데이터 정합성 이슈에 대한 완벽한 안전 장치
- read through + write through 조합
-- 데이터를 쓸 때 항상 캐시에 먼저 쓰므로, 읽어올 때 최신 캐시 데이터 보장
-- 데이터를 쓸 때 항상 캐시에서 DB로 보내므로, 데이터 정합성 보장
##### Cache Warming
-- cache read가 감지되지 않아도, 미리 cache로 db의 데이터를 밀어 넣어두는 작업
-- 서비스 초기에 트래픽 급증 시 대량의 cache miss를 방지한다.

-----
## celebrity(유명인사) 문제의 해결방법을 좀 더 알아보자
-- 기본적으로 샤딩키를 고르게 분포할 수 있도록 설정하는 것이 좋다. 순차적 기본키를 피하고 UUID와 같은 랜덤한 값을 샤딩키로 설정하는 것이 좋다.
-- 만약 한 샤딩키에 대해 높은 읽기/쓰기 쿼리가 존재한다면,  hash에 접미사를 붙이는 방법이 있다. JMomoa76라는 id가 존재한다면, 여기에 0부터 시작하는 1자리 숫자를 추가할 수 있다. (ex. JMomoa760~JMomoa769) 각 쓰기 요청에 대해 ID를 1씩 추가하여 수행하고, 가능한 모든 항목을 소진한 경우(9에 도달한 경우) 다시 0으로 재설정하여 다시 쓰기를 수행한다. 이 방법의 단점 중 하나는 데이터를 읽어야 할 때 JMomoa76의 어느 파티션에서 읽어야 할지 모른다. 이에 대해 몯느 파티션에서 읽기 쿼리를 수행하고 데이터를 병합해야 한다.

-----
# 추가 참고자료
https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EC%BA%90%EC%8B%9CCache-%EC%84%A4%EA%B3%84-%EC%A0%84%EB%9E%B5-%EC%A7%80%EC%B9%A8-%EC%B4%9D%EC%A0%95%EB%A6%AC
https://medium.com/garimoo/%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A0%88%EB%94%94%EC%8A%A4-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-02-f1029893e263
https://velog.io/@banggeunho/Redis-%EC%BA%90%EC%8B%9C%EB%9E%80-%EC%BA%90%EC%8B%B1%EC%A0%84%EB%9E%B5-%EC%95%8C%EA%B3%A0-%EC%8D%A8%EB%B3%B4%EC%9E%90
https://www.alibabacloud.com/blog/redis-hotspot-key-discovery-and-common-solutions_594446
https://www.cockroachlabs.com/blog/the-hot-content-problem-metadata-storage-for-media-streaming/
https://www.rkenmi.com/posts/sharding-user-ids-of-celebrities
