# 1장 - 사용자 수에 따른 규모 확장성

## 데이터베이스

### 어떤 데이터베이스를 사용할 것인가?

<b> 비-관계형 데이터베이스가 바람직한 선택인 경우 </b>

- 아주 낮은 응답 지연시간이 요구될 시
- 다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아닐 경우
- 데이터를(JSON,YAML,XML 등) 직렬화하거나 역직렬화 할 수 있기만 하면 됨
- 아주 많은 양의 데이터를 저장할 필요가 있을 경우

#### 직렬화 ? 역직렬화 ?

- 직렬화(Serialization): 데이터를 특정 형식으로 변환하여 일련의 바이트로 표현하는 과정을 의미한다.
  예를 들어, JSON, YAML, XML과 같은 형식으로 데이터를 표현하고, 이를 이진 형태로 변환하는 것을 직렬화라고 합니다. 이렇게 직렬화된 데이터는 파일이나 네트워크를 통해 전송하거나 저장할 수 있습니다.

- 역직렬화(Deserialization): 직렬화된 데이터를 다시 원래의 데이터 형식으로 변환하는 과정을 의미합니다. 이는 직렬화된 데이터를 다시 읽어와서 해당 데이터 형식으로 복원하는 작업을 말합니다.

이는 비관계형 데이터베이스가 유연한 데이터 형식을 다루는 데 유용하다는 특징을 나타냄.

- 그럼 관계형 DB는 직렬화 / 역직렬화 과정이 없는건가 ?
  -- 관계형 데이터베이스의 경우 데이터를 테이블 형태로 구조화하여 저장하고 관리하는데 중점.
  -- SQL 쿼리를 사용하여 조작하는것이 주 목적.
  -- 직렬화/역직렬화는 주로 비관계형 디비, 파일저장,네트워크 통신 등에서 활용되는 개념.
  -- 즉, 관계형 디비는 바이트 형식의 데이터를 주고 받기보단 정형화된 형태를 주로 다룸.

### 비정형 ? 정형 ?

- 정형 데이터 (Structured Data):
  정형 데이터는 데이터가 미리 정의된 구조나 스키마에 따라 구성된 형태. 각 데이터 필드는 명확하게 정의되고, 데이터의 타입이나 형식이 미리 알려진 상태.
  주로 관계형 데이터베이스 시스템에서 사용됩니다. 데이터베이스 내에서 테이블 형태로 저장되며, 각 열은 특정 <b>데이터 유형</b>을 나타내고 각 행은 개별 데이터 레코드를 나타냅니다.
  예시: 고객 정보, 주문 내역, 주소록 등

- 비정형 데이터 (Unstructured Data):
  비정형 데이터는 구조가 명확하게 정의되지 않은 형태의 데이터. 텍스트, 이미지, 오디오, 비디오, 소셜 미디어 게시물 등 다양한 형태의 데이터를 포함.
  데이터베이스의 테이블과 열 형태로는 저장하기 어려운 데이터 유형이며, 다양한 형식으로 저장 및 관리
  예시: 웹페이지, 이메일, 소셜 미디어 콘텐츠, 사진 및 동영상 파일 등

## 로드밸런서

- 사용자는 로드밸런서의 공개 IP주소로 접속
- 하지만, 서버 간 통신에는 사설 IP주소 이용
- 사설 IP주소는 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP주소이기에, 인터넷을 통해서 접속 불가능
- 로드밸런서는 웹 서버와 통시하기 위해 바로 이 사설 주소 사용

## 캐시

- 애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 따라 좌우됨.
- 캐시가 이 문제를 완화시켜줌.
- 캐시 게층은 데이터가 잠시 보관되는 곳으로 DB보다 훨씬 빠름.
- 주도형 캐시 전략 : 요청 받은 웹서버가 캐시에 응답이 저장 되어 있는지 확인하고 있으면 해당 요청에 대한 응답 반환, 없으면 데이터베이스 질의를 통해 데이터 찾은 후 캐시에 저장한 뒤 클라이언트에 반환.

### 캐시 사용 시 유의점

- 데이터 갱신은 자주 일어나지 않지만, 참조는 빈번 할 때
- 휘발성 메모리에 두므로, 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다.
- 중요한 데이터는 여전히 지속적 저장소에 두어야함.
- 캐시에 보관된 데이터는 어떻게 만료 되는가? 에 대한 정책이 중요함
- 만료된 데이터는 캐시에서 삭제되어야 한다. 만료정책이 없으면 데이터는 계속해서 캐시에 잔존. 만료기한이 너무 짧을 경우 DB를 너무 자주 읽게 되어 서버 부하 증가 반대로 너무 길면 원본과 차이가 날 가능성 존재함.
- 일관성은 어떻게 유지 되는가?, 일관성은 데이터 저장소의 원본과 캐시 내의 사본이 같은지에 대한 여부
- 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랙잭션으로 처리 되지 않으면 일관성이 깨질 가능성 존재.
- 여러 지역에 걸쳐 시스템을 확장해 나가는 경우 캐시와 저장소 사이의 일관성을 유지하는 것은 어려운 문제 (페이스북에서 내놓은 논문 <Scaling Memcache at Facebook> 참조)
- 장애에는 어떻게 대처? 캐시 서버를 한 대만 두는 경우 해당 서버는 단일 장애 지점(Single Point of Failure, SPOF)이 되어 버릴 가능성 존재.
- 단일 장애 지점 => " 어떤 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜버릴 수 있음 "
- 결과적으로, SPOF를 피하려면 여러 지역에 걸쳐 캐시 서버를 분산시켜야함.
- 캐시 메모리는 얼마나 크게 잡은 것인가? 캐시 메모리가 너무 작으면 엑세스 패턴에 따라서는 데이터가 너무 자주 캐시에서 밀려나버려 캐시의 성능 떨어짐. 이를 막을 한 가지 방법은 캐시 메모리를 과할당 하는 것.
- 데이터 방출 정책?
- 캐시가 꽉 차버리면 추가로 캐시에 데이터를 넣어야 할 경우 기존 데이터를 내보내야 함.
- 이것을 캐시 데이터 방출 정책이라고함
- 가장 널리 쓰이는 기법은 - LRU (Least Recently Used), 마지막으로 사용된 시점이 가장 오래된 데이터를 내보내는 정책
- 다른 정책으로는 LFU(Least Frequently Used),

## 무상태 웹 계층

- 상태 정보(사옹자 세션데이터)를 웹 계층에서 제거해야함
- 바람직한 전략은 상태 정보를 관계형 데이터베이스나 NoSQL 같은 지속성 저장소에 보관하고 필요할 때 가져오도록 함.
- 이렇게 구성된 웹 계층을 무상태 웹 계층.
- 상태 정보 의존적인 아키텍처는 한마디로 서버 1로 요청은 반드시 서버 1로 전송되어야 하는 것.
- 그래서 요청이 서버 2로 전송되면 인증 실패함.
- 이러한 문제는 같은 클라이언트의 요청은 모두 같은 서버로 전송되어야 한다는 점.
- 대부분의 로드밸런서가 이를 지원하기 위해 고정 세션이라는 기능을 제공하긴 하는데 이는 로드밸런서에 많은 부담이 됨.

### 무상태 아키텍처

- 이 구조(공유저장소를 따로 둔 아키텍처)에서는 어떠한 사용자의 요청이든 어떤 웹서버로도 전달 가능
- 웹 서버는 상태 정보가 필요할 경우 <b> 공유 저장소 </b>로부터 데이터를 가져옴
- 따라서 상태정보는 웹 서버로부터 물리적으로 분리되어 있음.
- 공유 데이터 저장소를 NoSQL로 설정시, 규모 확장이 간편해짐.

## 메시지 큐

- 메시지 큐는 메시지의 무손실(즉, 메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때 까지 안전히 보관된다는 특성)을 보장하는, 비동기 통신을 지원하는 컴포넌트.
- 메시지의 버퍼 역할을하며, 비동기적으로 전송.
- 메시지 큐의 기본 아키텍처 : 생산자 또는 발행자 (producer / publisher) 라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행 (publish).
- 큐에는 보통 소비자 혹은 구독자(consumer/subscriber)라 불리는 서비스 혹은 서버가 연결되어 있는데, 메시지를 받아 그에 맞는 동작 수행.
- 메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모의 확장성이 보장되어야 하는 안정적 애플리케이션 구성하기 좋음.
- 소비자는 생산자가 가용한 상태가 아니더라도 메시지 소비 가능
- 사용 예) 이미지의 크로핑,샤프닝,블러링을 지원하는 사진 보정 어플리케이션에서 이러한 보정은 시간이 오래 걸릴 수 있는 프로세스이므로 비동기적으로 처리하면 편함
- 따라서, 사진 보정 작업(job)들을 메시지 큐에 넣는다. 사진 보정 작업(worker) 프로세스들은 이 작업을 메시지 큐에서 꺼내어 비동기적으로 수행
- 이렇게 하면 생산자와 소비자가 각기 독립적으로 확장 가능하다.

## 데이터베이스 규모 확장

### 수평적 확장

- 데이터베이스의 수평적 확장 -> 샤딩(sharding)
- 더 많은 서버를 추가함으로써 성능 향상
- 샤딩은 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술
- 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복 X
- 가령, user_id % 4 를 해시 함수로 사용하여 데이처가 보관되는 샤드를 정함.
- 결과가 0 이면 0번 샤드에, 1이면 1번 샤드에 보관해서 데이터 중복이 있을 수 없게 함.
- 샤딩 전략을 구현할 때 고려해야 할 가장 중요한 것은 샤딩 키 (Sharding Key)
- 샤딩키는 파디션 키라고도 부르는데, 데이터가 어떻게 분산될지 정하는 하나 이상의 컬럼으로 구성 (EX: user_id)
- 샤딩키를 정할 떄는 데이터를 고르게 분할 할 수 있도록 하는게 가장 중요
- 샤딩 문제점
  -- 1) 데이터 재 샤딩 : 특정 DB 서버만 유독 데이터가 많아져서 데이터 분포가 균등하지 못해 특정 서버만 샤드 소진이 빨리 진행될 때, 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치 하여야 함.
  -- 2) 유명인사 문제 : 핫스팟 키 문제라고도 부르는데, 특정 샤드에 질의가 집중되어 서버에 과부하 발생. 가령 전지현, 수지와 같은 유명인사가 전부 같은 샤드에 저장돼있고 사회 관계명 애플리케이션 서비스 구축시 해당 샤드는 과부하가 발생될 확률이 큼. (I Love..)
  -- 3) 조인과 비정규화 : 하나의 디비를 여러개로 쪼개면 여러 샤드에 걸친 데이터 조인이 수행이 힘듦. 이를 해결하기 위해선 디비를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것.

#### 내가 선택한 키워드 : 메시지큐, 샤딩(Sharding)

### 추후 공부 키워드

- CDN 서버 죽었을때, 어떻게 대처하는가 ?
- 기업별 캐시전략 ?
- 세션 데이터 저장 관리법
- GeoDNS 동작원리
- 특정 데이터센터 장애시, 트래픽 우회법
- 데이터베이스 다중화 전략 (데이터를 여러 데이터센터에 다중)
- 메시지큐를 활용한 시스템 컴포넌트 분리를 통한 확장법
- 메시지큐 사용 예
- DB 수평적 VS 수직적 Scale Up ?
- 샤딩 키 설정법 (파티션 키)
- 샤딩 문제점
